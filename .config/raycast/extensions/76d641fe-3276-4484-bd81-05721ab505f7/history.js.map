{
  "version": 3,
  "sources": ["../src/history.tsx", "../src/videos.tsx", "../src/storage.tsx", "../src/utils.tsx", "../src/constants.tsx"],
  "sourcesContent": ["import { Videos } from \"./videos\";\n\nexport default function Command() {\n  return <Videos files={[]} />;\n}\n", "import { Action, ActionPanel, Grid, Icon, showInFinder } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { getHistoryFromStorage, saveHistoryToStorage } from \"./storage\";\nimport { fileName, unique } from \"./utils\";\n\nexport function Videos(props: { files: string[] }) {\n  const [history, setHistory] = useState<string[] | null>(null);\n  const [allFiles, setAllFiles] = useState<string[]>(props.files);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    getHistoryFromStorage()\n      .then((fromStorage) => {\n        if (fromStorage) setHistory(fromStorage);\n        else setHistory([]);\n      })\n      .finally(() => setIsLoading(false));\n  }, []);\n\n  useEffect(() => {\n    if (history) {\n      const newFiles = [...props.files, ...history];\n      setAllFiles(newFiles);\n      saveHistoryToStorage(newFiles);\n    }\n  }, [history, props.files]);\n\n  const removeFromHistory = (file: string) => {\n    saveHistoryToStorage(allFiles.filter((f) => f !== file));\n    setAllFiles(allFiles.filter((f) => f !== file));\n  };\n\n  const clearAllHistory = () => {\n    saveHistoryToStorage([]);\n    setAllFiles([]);\n  };\n\n  return (\n    <Grid isLoading={isLoading}>\n      {unique(allFiles).map((file, index) => (\n        <Grid.Item\n          id={index.toString()}\n          key={file}\n          title={fileName(file)}\n          content={{ fileIcon: file }}\n          quickLook={{ path: file }}\n          accessory={\n            index < props.files.length ? { icon: { source: Icon.Checkmark, tintColor: \"#008080\" } } : undefined\n          }\n          actions={\n            <ActionPanel>\n              <Action.CopyToClipboard content={{ file }} />\n              <Action.ToggleQuickLook />\n              <Action.Open title=\"Open\" target={file} />\n              <Action.OpenWith path={file} />\n              <Action title=\"Open in Finder\" onAction={() => showInFinder(file)} icon={{ source: Icon.Finder }} />\n              <Action\n                title=\"Remove From History\"\n                style={Action.Style.Destructive}\n                onAction={() => removeFromHistory(file)}\n                icon={{ source: Icon.Trash }}\n              />\n              <Action\n                title=\"Clear All History\"\n                style={Action.Style.Destructive}\n                onAction={clearAllHistory}\n                icon={{ source: Icon.Trash }}\n              />\n            </ActionPanel>\n          }\n        />\n      ))}\n    </Grid>\n  );\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport { fileExists } from \"./utils\";\n\ntype StorageItem = {\n  file: string;\n  timestamp: number;\n};\n\nconst STORAGE_KEY = \"videos-history\";\nconst OLDER_THAN = 1000 * 60 * 60 * 24 * 7; // 1 week\n\nfunction isNotTooOld({ timestamp }: StorageItem) {\n  return Date.now() - timestamp < OLDER_THAN;\n}\n\nexport async function saveHistoryToStorage(files: string[]) {\n  const items: StorageItem[] = files.map((file) => ({ file, timestamp: Date.now() }));\n  return LocalStorage.setItem(STORAGE_KEY, JSON.stringify(items));\n}\n\nexport async function getHistoryFromStorage(): Promise<string[] | null> {\n  const items = await LocalStorage.getItem(STORAGE_KEY);\n  if (!items) return null;\n  if (typeof items !== \"string\") return null;\n\n  const parsedItems: StorageItem[] = JSON.parse(items);\n  return parsedItems\n    .filter(isNotTooOld)\n    .map((item) => item.file)\n    .filter(fileExists);\n}\n\nexport async function removeFromHistoryStorage(file: string) {\n  const items = await LocalStorage.getItem(STORAGE_KEY);\n  if (!items) return;\n  if (typeof items !== \"string\") return null;\n\n  const parsedItems: StorageItem[] = JSON.parse(items);\n\n  const newItems = parsedItems.filter((item) => item.file !== file);\n  return LocalStorage.setItem(STORAGE_KEY, JSON.stringify(newItems));\n}\n", "import { Toast, showToast } from \"@raycast/api\";\nimport { exec, execSync } from \"child_process\";\nimport fs, { existsSync } from \"fs\";\nimport { promisify } from \"util\";\nimport { COMPRESSION_OPTIONS, CompressionOptionKey, FFMPEG_BINARY_CUSTOM_PATH, PATH, VIDEO_FORMATS } from \"./constants\";\n\nconst ffmpegPathExists = (): boolean => {\n  try {\n    return existsSync(FFMPEG_BINARY_CUSTOM_PATH);\n  } catch (error) {\n    return false;\n  }\n};\n\nconst isFFmpegInstalledOnPath = (): boolean => {\n  try {\n    const result = execSync(`zsh -l -c 'PATH=${PATH} ffmpeg -version'`).toString();\n    if (result.includes(\"ffmpeg version\")) {\n      return true;\n    }\n    return false;\n  } catch (error) {\n    return false;\n  }\n};\n\nexport function normalizeFilePath(filePath: string): string {\n  return filePath.replace(/^file:\\/\\//, \"\").replace(/%20/g, \" \");\n}\n\nexport function fileName(filePath: string): string {\n  return filePath.split(\"/\").pop()!;\n}\n\nexport function unique<T>(array: T[]): T[] {\n  return [...new Set(array)];\n}\n\nexport function fileExists(file: string) {\n  return fs.existsSync(file);\n}\n\nconst getFFmpegCommand = (args: string) => {\n  const isInPath = isFFmpegInstalledOnPath();\n  const customPathExists = ffmpegPathExists();\n\n  if (isInPath) {\n    return `zsh -l -c 'PATH=${PATH} ffmpeg ${args}'`;\n  } else if (customPathExists) {\n    return `${FFMPEG_BINARY_CUSTOM_PATH} ${args}`;\n  } else {\n    showToast({\n      title: \"Error\",\n      message: \"FFmpeg is not installed. Please install FFmpeg or specify its path in the extension settings.\",\n      style: Toast.Style.Failure,\n    });\n    return null;\n  }\n};\n\nexport function sanitizeFileName(file: string): string {\n  return file\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/ /g, \"\\\\ \")\n    .replace(/`/g, \"\\\\`\")\n    .replace(/\"/g, `\\\\\"`)\n    .replace(/\\$/g, `\\\\$`)\n    .replace(/\\(/g, \"\\\\(\")\n    .replace(/\\)/g, \"\\\\)\");\n}\n\nexport async function compressVideoFiles(files: string[], compression: CompressionOptionKey): Promise<string[]> {\n  const one = files.length === 1;\n  await showToast(Toast.Style.Animated, one ? \"Compressing video...\" : \"Compressing videos...\");\n\n  const results = await Promise.all(\n    files.map(async (file) => {\n      const output = file.replace(/\\.\\w+$/, ` (yafw ${compression}).mp4`);\n      const { crf, bitrate, bufsize } = COMPRESSION_OPTIONS[compression];\n      const command = getFFmpegCommand(\n        `-y -i ${sanitizeFileName(file)} -vcodec libx264 -crf ${crf} -b:v ${bitrate} -bufsize ${bufsize} ${sanitizeFileName(output)}`,\n      );\n\n      if (!command) {\n        return [];\n      }\n\n      return promisify(exec)(command).then(({ stdout, stderr }) => {\n        console.log(stdout);\n        console.log(stderr);\n        return output;\n      });\n    }),\n  );\n\n  const successfulFiles = results.filter(Boolean) as string[];\n\n  if (successfulFiles.length !== files.length) {\n    showToast({\n      title: \"Error\",\n      message: \"Some files could not be compressed.\",\n      style: Toast.Style.Failure,\n    });\n  } else {\n    showToast({\n      title: \"Success\",\n      message: `Successfully compressed all files.`,\n      style: Toast.Style.Success,\n    });\n  }\n\n  return successfulFiles;\n}\n\nexport function capitalizeSnakeCase(text: string): string {\n  return text\n    .split(\"_\")\n    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))\n    .join(\" \");\n}\n\nexport function isFileFormatSupported(_filename: string): boolean {\n  const filename = _filename.toLowerCase();\n  return VIDEO_FORMATS.some((format) => filename.endsWith(format));\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport type CompressionOptionKey = \"best_quality\" | \"balanced\" | \"small_file\" | \"very_small_file\";\nexport type CompressionOption = { crf: number; bitrate: string; bufsize: string };\nexport const COMPRESSION_OPTIONS: Record<CompressionOptionKey, CompressionOption> = {\n  best_quality: { crf: 23, bitrate: \"3000k\", bufsize: \"6000k\" },\n  balanced: { crf: 28, bitrate: \"2000k\", bufsize: \"4000k\" },\n  small_file: { crf: 35, bitrate: \"1000k\", bufsize: \"2000k\" },\n  very_small_file: { crf: 42, bitrate: \"500k\", bufsize: \"1000k\" },\n};\nexport const DEFAULT_COMPRESSION: CompressionOptionKey = \"balanced\";\nexport const VIDEO_FORMATS = [\"mp4\", \"mov\", \"avi\", \"mkv\", \"webm\", \"gif\"];\nexport const PATH = [\n  \".\",\n  \"/bin\",\n  \"~/.bin\",\n  \"/usr/bin\",\n  \"/usr/gnu/bin\",\n  \"/usr/local/bin\",\n  \"/opt/homebrew/bin\",\n  \"/opt/homebrew/sbin\",\n  \"/usr/local/Cellar/ffmpeg\",\n].join(\":\");\nexport const FFMPEG_BINARY_CUSTOM_PATH = getPreferenceValues().ffmpeg_path ?? \"/opt/homebrew/bin/ffmpeg\";\n"],
  "mappings": "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",
  "names": ["history_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "import_api", "import_fs", "import_api", "PATH", "FFMPEG_BINARY_CUSTOM_PATH", "fileName", "filePath", "unique", "array", "fileExists", "file", "fs", "STORAGE_KEY", "OLDER_THAN", "isNotTooOld", "timestamp", "saveHistoryToStorage", "files", "items", "file", "getHistoryFromStorage", "item", "fileExists", "import_jsx_runtime", "Videos", "props", "history", "setHistory", "allFiles", "setAllFiles", "isLoading", "setIsLoading", "getHistoryFromStorage", "fromStorage", "newFiles", "saveHistoryToStorage", "removeFromHistory", "file", "f", "clearAllHistory", "unique", "index", "fileName", "import_jsx_runtime", "Command", "Videos"]
}
