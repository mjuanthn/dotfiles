{
  "version": 3,
  "sources": ["../src/stabilize.tsx", "../src/objects/encode.operation.ts", "../src/objects/ffmpeg.ts", "../src/constants.tsx", "../src/utils.tsx", "../src/objects/fs.binary.ts", "../src/objects/ffmpeg.video.ts", "../src/objects/fs.file.ts", "../src/objects/ffprobe.ts", "../src/objects/safe.operation.ts", "../src/objects/selected-finder.files.ts", "../src/objects/toast.ts", "../src/objects/trimmed.string.ts"],
  "sourcesContent": ["import { Toast as RaycastToast } from \"@raycast/api\";\nimport { EncodeOperation } from \"./objects/encode.operation\";\nimport { Ffmpeg } from \"./objects/ffmpeg\";\nimport { FfmpegVideo } from \"./objects/ffmpeg.video\";\nimport { Ffprobe } from \"./objects/ffprobe\";\nimport { SafeOperation } from \"./objects/safe.operation\";\nimport { SelectedFinderFiles } from \"./objects/selected-finder.files\";\nimport { Toast } from \"./objects/toast\";\n\nexport default async function Command() {\n  const files = new SelectedFinderFiles();\n  const toast = new Toast();\n  const ffmpeg = new Ffmpeg(new Ffprobe(), {\n    onProgressChange: async (progress) => {\n      await toast.updateProgress(Math.round(progress * 100));\n    },\n  });\n\n  await new SafeOperation(\n    new EncodeOperation(files, async (selectedFiles) => {\n      // @NOTE: I don't think this is a valuable command for GIFs at all.\n      // But it could easily be included if we decide to do so.\n      // Beware that this feature has not been tested on GIFs, so please test it if you enable it.\n      if (selectedFiles.some((file) => file.extension() === \".gif\")) {\n        throw new Error(\"Does not applicable to GIFs yet\");\n      }\n\n      for (const file of selectedFiles) {\n        await toast.show({\n          title: `Stabilizing \"${file.name()}${file.extension()}\"`,\n          style: RaycastToast.Style.Animated,\n        });\n        await new FfmpegVideo(ffmpeg, file).stabilize();\n      }\n    }),\n    toast,\n  ).run();\n}\n", "import { showHUD } from \"@raycast/api\";\nimport { Files, Operation } from \"../abstractions\";\n\nexport class NoFilesProvidedException extends Error {}\n\n/**\n * Run encode operation on specified files.\n * @throws if no files provided.\n */\nexport class EncodeOperation implements Operation {\n  constructor(\n    private readonly files: Files,\n    private readonly operation: (files: Awaited<ReturnType<Files[\"list\"]>>) => Promise<void>,\n  ) {}\n\n  run: Operation[\"run\"] = async () => {\n    const files = await this.files.list();\n\n    if (files.length === 0) {\n      throw new NoFilesProvidedException();\n    }\n\n    await this.operation(files);\n\n    await showHUD(\"All Videos are Processed\");\n  };\n}\n", "import { exec } from \"child_process\";\nimport path from \"path\";\nimport { Binary } from \"../abstractions\";\nimport { FFMPEG_BINARY_CUSTOM_PATH, PATH } from \"../constants\";\nimport { sanitizeFileName } from \"../utils\";\nimport { Ffprobe } from \"./ffprobe\";\nimport { FsBinary } from \"./fs.binary\";\n\nexport class FfmpegBinaryNotFoundException extends Error {}\n\n/**\n * Ffmpeg wrapper\n */\nexport class Ffmpeg {\n  private readonly ffmpegBinary: Binary;\n\n  constructor(\n    private readonly ffprobe: Ffprobe,\n    private readonly callbacks?: {\n      onProgressChange?: (progress: number) => void;\n    },\n    ffmpegBinary?: Binary,\n  ) {\n    this.ffmpegBinary =\n      ffmpegBinary ??\n      new FsBinary(\n        // @TODO: refactor to remove path from strict dependencies here\n        [...PATH.split(\":\"), path.dirname(FFMPEG_BINARY_CUSTOM_PATH)].filter((p) => !!p).join(\":\"),\n        \"ffmpeg\",\n      );\n  }\n\n  /**\n   * @todo add validations for params?\n   */\n  exec: (payload: { input: string; output?: string; params?: (string | undefined)[] }) => Promise<void> = async (\n    payload,\n  ) => {\n    const { input, params, output } = payload;\n\n    if (input === output) {\n      throw new Error(\"Cannot override source\");\n    }\n\n    if (input.includes(\"ffmpeg\")) {\n      throw new Error(\"Path to ffmpeg command included automatically. Start your command directly from arguments\");\n    }\n\n    if (this.ffmpegBinary.exists() === false) {\n      throw new FfmpegBinaryNotFoundException();\n    }\n\n    const durationInSeconds = await this.ffprobe.exec({\n      input,\n      params: [\"-v error\", \"-show_entries format=duration\", \"-of default=noprint_wrappers=1:nokey=1\"],\n    });\n\n    return new Promise<void>((resolve, reject) => {\n      // @NOTE: ffmpeg uses nanoseconds as milliseconds for some reason\n      const durationInMilliseconds = parseFloat(durationInSeconds) * 1000 * 1000;\n\n      const command = this.ffmpegBinary.command(\n        [\n          \"-y\",\n          `-i ${sanitizeFileName(input)}`,\n          ...(params ?? []),\n          output ? \"-progress pipe:1\" : undefined,\n          output ? sanitizeFileName(output) : undefined,\n        ]\n          .filter((param) => param != null)\n          .join(\" \"),\n      );\n      const ffmpegProcess = exec(command);\n\n      ffmpegProcess.stderr?.on(\"data\", (data) => {\n        console.log(\"ffmpeg stderr\", data);\n      });\n\n      /**\n       * Ffmpeg logs the progress as follows:\n       * frame=266 fps=240.97 stream_0_0_q=-1.0 bitrate= 254.7kbits/s total_size=140098 out_time_us=4400000 out_time_ms=4400000 out_time=00:00:04.400000 dup_frames=0 drop_frames=0 speed=3.99x progress=continue\n       * frame=266 fps=240.97 stream_0_0_q=-1.0 bitrate= 254.7kbits/s total_size=140098 out_time_us=4400000 out_time_ms=4400000 out_time=00:00:04.400000 dup_frames=0 drop_frames=0 speed=3.99x progress=end\n       */\n      ffmpegProcess.stdout?.on(\"data\", (data) => {\n        console.log(\"ffmpeg stdout\", data);\n        const parts = (data as string).split(\"\\n\");\n        let outTimeMs: string | undefined;\n\n        for (const part of parts) {\n          if (part.includes(\"out_time_ms=\")) {\n            outTimeMs = part.split(\"=\")[1];\n          }\n        }\n\n        if (outTimeMs != null) {\n          // @NOTE: handle rare cases when parse happen incorrectly\n          const parsed = parseFloat(outTimeMs);\n          if (Number.isNaN(parsed)) {\n            return;\n          }\n\n          this.callbacks?.onProgressChange?.(parseFloat(outTimeMs) / durationInMilliseconds);\n        }\n      });\n\n      ffmpegProcess.on(\"error\", (error) => {\n        console.error(\"ffmpeg process error:\", error);\n        reject(error);\n      });\n\n      ffmpegProcess.on(\"exit\", (code, signal) => {\n        if (code === 0) {\n          console.log(\"Video creation completed successfully.\");\n          resolve();\n        } else {\n          console.error(`ffmpeg process exited with code ${code} and signal ${signal}`);\n          reject(new Error(`ffmpeg process exited with code ${code} and signal ${signal}`));\n        }\n      });\n    });\n  };\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport type CompressionOptionKey = \"best_quality\" | \"balanced\" | \"small_file\" | \"very_small_file\";\nexport type CompressionOption = { crf: number; bitrate: string; bufsize: string };\nexport const COMPRESSION_OPTIONS: Record<CompressionOptionKey, CompressionOption> = {\n  best_quality: { crf: 23, bitrate: \"3000k\", bufsize: \"6000k\" },\n  balanced: { crf: 28, bitrate: \"2000k\", bufsize: \"4000k\" },\n  small_file: { crf: 35, bitrate: \"1000k\", bufsize: \"2000k\" },\n  very_small_file: { crf: 42, bitrate: \"500k\", bufsize: \"1000k\" },\n};\nexport const DEFAULT_COMPRESSION: CompressionOptionKey = \"balanced\";\nexport const VIDEO_FORMATS = [\"mp4\", \"mov\", \"avi\", \"mkv\", \"webm\", \"gif\"];\nexport const PATH = [\n  \".\",\n  \"/bin\",\n  \"~/.bin\",\n  \"/usr/bin\",\n  \"/usr/gnu/bin\",\n  \"/usr/local/bin\",\n  \"/opt/homebrew/bin\",\n  \"/opt/homebrew/sbin\",\n  \"/usr/local/Cellar/ffmpeg\",\n].join(\":\");\nexport const FFMPEG_BINARY_CUSTOM_PATH = getPreferenceValues().ffmpeg_path ?? \"/opt/homebrew/bin/ffmpeg\";\n", "import { Toast, showToast } from \"@raycast/api\";\nimport { exec, execSync } from \"child_process\";\nimport fs, { existsSync } from \"fs\";\nimport { promisify } from \"util\";\nimport { COMPRESSION_OPTIONS, CompressionOptionKey, FFMPEG_BINARY_CUSTOM_PATH, PATH, VIDEO_FORMATS } from \"./constants\";\n\nconst ffmpegPathExists = (): boolean => {\n  try {\n    return existsSync(FFMPEG_BINARY_CUSTOM_PATH);\n  } catch (error) {\n    return false;\n  }\n};\n\nconst isFFmpegInstalledOnPath = (): boolean => {\n  try {\n    const result = execSync(`zsh -l -c 'PATH=${PATH} ffmpeg -version'`).toString();\n    if (result.includes(\"ffmpeg version\")) {\n      return true;\n    }\n    return false;\n  } catch (error) {\n    return false;\n  }\n};\n\nexport function normalizeFilePath(filePath: string): string {\n  return filePath.replace(/^file:\\/\\//, \"\").replace(/%20/g, \" \");\n}\n\nexport function fileName(filePath: string): string {\n  return filePath.split(\"/\").pop()!;\n}\n\nexport function unique<T>(array: T[]): T[] {\n  return [...new Set(array)];\n}\n\nexport function fileExists(file: string) {\n  return fs.existsSync(file);\n}\n\nconst getFFmpegCommand = (args: string) => {\n  const isInPath = isFFmpegInstalledOnPath();\n  const customPathExists = ffmpegPathExists();\n\n  if (isInPath) {\n    return `zsh -l -c 'PATH=${PATH} ffmpeg ${args}'`;\n  } else if (customPathExists) {\n    return `${FFMPEG_BINARY_CUSTOM_PATH} ${args}`;\n  } else {\n    showToast({\n      title: \"Error\",\n      message: \"FFmpeg is not installed. Please install FFmpeg or specify its path in the extension settings.\",\n      style: Toast.Style.Failure,\n    });\n    return null;\n  }\n};\n\nexport function sanitizeFileName(file: string): string {\n  return file\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/ /g, \"\\\\ \")\n    .replace(/`/g, \"\\\\`\")\n    .replace(/\"/g, `\\\\\"`)\n    .replace(/\\$/g, `\\\\$`)\n    .replace(/\\(/g, \"\\\\(\")\n    .replace(/\\)/g, \"\\\\)\");\n}\n\nexport async function compressVideoFiles(files: string[], compression: CompressionOptionKey): Promise<string[]> {\n  const one = files.length === 1;\n  await showToast(Toast.Style.Animated, one ? \"Compressing video...\" : \"Compressing videos...\");\n\n  const results = await Promise.all(\n    files.map(async (file) => {\n      const output = file.replace(/\\.\\w+$/, ` (yafw ${compression}).mp4`);\n      const { crf, bitrate, bufsize } = COMPRESSION_OPTIONS[compression];\n      const command = getFFmpegCommand(\n        `-y -i ${sanitizeFileName(file)} -vcodec libx264 -crf ${crf} -b:v ${bitrate} -bufsize ${bufsize} ${sanitizeFileName(output)}`,\n      );\n\n      if (!command) {\n        return [];\n      }\n\n      return promisify(exec)(command).then(({ stdout, stderr }) => {\n        console.log(stdout);\n        console.log(stderr);\n        return output;\n      });\n    }),\n  );\n\n  const successfulFiles = results.filter(Boolean) as string[];\n\n  if (successfulFiles.length !== files.length) {\n    showToast({\n      title: \"Error\",\n      message: \"Some files could not be compressed.\",\n      style: Toast.Style.Failure,\n    });\n  } else {\n    showToast({\n      title: \"Success\",\n      message: `Successfully compressed all files.`,\n      style: Toast.Style.Success,\n    });\n  }\n\n  return successfulFiles;\n}\n\nexport function capitalizeSnakeCase(text: string): string {\n  return text\n    .split(\"_\")\n    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))\n    .join(\" \");\n}\n\nexport function isFileFormatSupported(_filename: string): boolean {\n  const filename = _filename.toLowerCase();\n  return VIDEO_FORMATS.some((format) => filename.endsWith(format));\n}\n", "import { execSync } from \"child_process\";\nimport { Binary } from \"../abstractions\";\n\nexport class FsBinary implements Binary {\n  constructor(\n    /**\n     * column separated path to folders.\n     * @example '/bin:/homebrew/bin'\n     */\n    private readonly foldersPath: string,\n    private readonly fileName: string,\n  ) {}\n\n  path: Binary[\"path\"] = () => {\n    return this.foldersPath;\n  };\n\n  exists: Binary[\"exists\"] = () => {\n    try {\n      execSync(`zsh -l -c 'PATH=${this.path()} which ${this.fileName}'`);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n\n  command: Binary[\"command\"] = (args) => `zsh -l -c 'PATH=${this.path()} ${this.fileName} ${args}'`;\n}\n", "import path from \"path\";\nimport { File, Video } from \"../abstractions\";\nimport { Ffmpeg } from \"./ffmpeg\";\nimport { FsFile } from \"./fs.file\";\n\nexport class FfmpegVideo implements Video {\n  constructor(\n    private readonly ffmpeg: Ffmpeg,\n    private readonly file: File,\n  ) {}\n\n  encode: Video[\"encode\"] = async (options = {}) => {\n    const { preset, width, height, format } = options;\n\n    const videoPath = this.file.path();\n    const sourceDirPath = path.dirname(videoPath);\n    const extension = format ? `.${format}` : path.extname(videoPath);\n    const targetVideoPath = path.join(sourceDirPath, this.file.nextName({ extension }));\n\n    const codec = extension === \"webm\" ? \"libvpx-vp9\" : \"libx264\";\n    const bitrate = (() => {\n      switch (preset) {\n        case \"best-quality\": {\n          return \"10M\";\n        }\n        case \"optimal\": {\n          return \"4M\";\n        }\n        case \"smallest-size\": {\n          return \"2M\";\n        }\n        default: {\n          return \"4M\";\n        }\n      }\n    })();\n\n    await this.ffmpeg.exec({\n      input: videoPath,\n      params: [\n        preset != null ? `-c:v ${codec} -b:v ${bitrate}` : undefined,\n        !!width && !height ? `-vf scale=${width}:-2` : undefined,\n        !width && !!height ? `-vf scale=-2:${height}` : undefined,\n        !!width && !!height ? `-vf scale=${width}:${height}` : undefined,\n      ],\n      output: targetVideoPath,\n    });\n  };\n\n  stabilize: Video[\"stabilize\"] = async () => {\n    const videoPath = this.file.path();\n    const sourceDirPath = path.dirname(videoPath);\n    const extension = this.file.extension();\n    const targetVideoPath = path.join(sourceDirPath, this.file.nextName({ extension }));\n    const transforms = new FsFile(path.join(sourceDirPath, \"transforms.trf\"));\n\n    try {\n      await this.ffmpeg.exec({\n        input: videoPath,\n        params: [`-vf vidstabdetect=shakiness=4:accuracy=15:result=\"${transforms.path()}\" -f null -`],\n      });\n      await this.ffmpeg.exec({\n        input: videoPath,\n        params: [`-vf vidstabtransform=smoothing=12:zoom=0:input=\"${transforms.path()}\"`],\n        output: targetVideoPath,\n      });\n    } finally {\n      await new FsFile(path.join(sourceDirPath, \"transforms.trf\")).remove();\n    }\n  };\n}\n", "import fs from \"fs\";\nimport afs from \"fs/promises\";\nimport path from \"path\";\nimport { File } from \"../abstractions\";\n\nexport class FsFile implements File {\n  constructor(private readonly _path: string) {}\n\n  path: File[\"path\"] = () => this._path;\n\n  extension: File[\"extension\"] = () => path.extname(this._path);\n\n  name: File[\"name\"] = () => path.basename(this._path, this.extension());\n\n  nextName: File[\"nextName\"] = (options = {}) => {\n    const { extension, counter = 0 } = options;\n    const dirPath = path.dirname(this._path);\n    const currentExtension = path.extname(this._path);\n    const baseName = path.basename(this._path, currentExtension);\n    const splitted = baseName.split(\" \");\n    const lastPart = splitted[splitted.length - 1];\n    const digitsInName = parseInt(lastPart, 10);\n    const isLastPartDigits = digitsInName.toString() === lastPart && Number.isNaN(digitsInName) === false;\n    const baseNameWithoutDigits = splitted.slice(0, -1).join(\" \");\n    const nextName = (() => {\n      if (isLastPartDigits) {\n        return `${baseNameWithoutDigits} (${digitsInName + counter + 1})`;\n      }\n\n      return `${baseName} (${counter + 1})`;\n    })();\n    const nextPath = path.join(dirPath, `${nextName}${extension ?? currentExtension}`);\n\n    if (fs.existsSync(nextPath)) {\n      return this.nextName({\n        extension,\n        counter: counter + 1,\n      });\n    }\n\n    return `${nextName}${extension ?? currentExtension}`;\n  };\n\n  remove: File[\"remove\"] = async () => {\n    await afs.rm(this.path());\n  };\n}\n", "import { execSync } from \"child_process\";\nimport path from \"path\";\nimport { Binary } from \"../abstractions\";\nimport { FFMPEG_BINARY_CUSTOM_PATH, PATH } from \"../constants\";\nimport { sanitizeFileName } from \"../utils\";\nimport { FsBinary } from \"./fs.binary\";\n\nexport class FfprobeBinaryNotFoundException extends Error {}\n\n/**\n * Ffprobe wrapper\n */\nexport class Ffprobe {\n  private readonly ffprobeBinary: Binary;\n\n  constructor(ffprobeBinary?: Binary) {\n    this.ffprobeBinary =\n      ffprobeBinary ??\n      new FsBinary(\n        // @TODO: refactor to remove path from strict dependencies here\n        [...PATH.split(\":\"), path.dirname(FFMPEG_BINARY_CUSTOM_PATH)].filter((p) => !!p).join(\":\"),\n        \"ffprobe\",\n      );\n  }\n\n  /**\n   * @todo add validations for params?\n   */\n  exec: (payload: { input: string; params?: (string | undefined)[] }) => Promise<string> = async (payload) => {\n    const { input, params } = payload;\n\n    if (input.includes(\"ffprobe\")) {\n      throw new Error(\"Path to ffprobe command included automatically. Start your command directly from arguments\");\n    }\n\n    if (this.ffprobeBinary.exists() === false) {\n      throw new FfprobeBinaryNotFoundException();\n    }\n\n    // ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4\n    const command = this.ffprobeBinary.command(\n      [...(params ?? []), sanitizeFileName(input)].filter((param) => param != null).join(\" \"),\n    );\n    const result = execSync(command);\n    return result.toString();\n  };\n}\n", "import { Toast as RaycastToast } from \"@raycast/api\";\nimport { Operation } from \"../abstractions\";\nimport { NoFilesProvidedException } from \"./encode.operation\";\nimport { FfmpegBinaryNotFoundException } from \"./ffmpeg\";\nimport { FfprobeBinaryNotFoundException } from \"./ffprobe\";\nimport { FinderIsNotFrontmostAppException } from \"./selected-finder.files\";\nimport { Toast } from \"./toast\";\n\n/**\n * Run any operation, catch all possible errors and show toast if any.\n */\nexport class SafeOperation implements Operation {\n  constructor(\n    private readonly origin: Operation,\n    private readonly toast: Toast,\n  ) {}\n\n  run: Operation[\"run\"] = async () => {\n    try {\n      await this.origin.run();\n    } catch (err) {\n      if (err instanceof FfmpegBinaryNotFoundException || err instanceof FfprobeBinaryNotFoundException) {\n        await this.toast.show({\n          title: \"FFmpeg is not installed. Please install FFmpeg or specify its path in the extension settings.\",\n          style: RaycastToast.Style.Failure,\n        });\n        return;\n      }\n\n      if (err instanceof FinderIsNotFrontmostAppException) {\n        await this.toast.show({ title: \"Please put Finder in focus and try again\", style: RaycastToast.Style.Failure });\n        return;\n      }\n\n      if (err instanceof NoFilesProvidedException) {\n        await this.toast.show({ title: \"Please select any Video in Finder\", style: RaycastToast.Style.Failure });\n        return;\n      }\n\n      if (err instanceof Error) {\n        console.error(err);\n        await this.toast.show({ title: err.message, style: RaycastToast.Style.Failure });\n      }\n    }\n  };\n}\n", "import { getFrontmostApplication, getSelectedFinderItems } from \"@raycast/api\";\nimport { Files } from \"../abstractions\";\nimport { isFileFormatSupported } from \"../utils\";\nimport { FsFile } from \"./fs.file\";\n\nexport class FinderIsNotFrontmostAppException extends Error {}\n\nexport class SelectedFinderFiles implements Files {\n  /**\n   * Gets currently selected videos in Finder.\n   */\n  list: Files[\"list\"] = async () => {\n    const frontmostApp = await getFrontmostApplication();\n\n    if (frontmostApp.name !== \"Finder\") {\n      throw new FinderIsNotFrontmostAppException();\n    }\n\n    const paths = await getSelectedFinderItems();\n    return paths\n      .filter((filePath) => isFileFormatSupported(filePath.path))\n      .map((filePath) => new FsFile(filePath.path));\n  };\n}\n", "import { Toast as RaycastToast, showToast } from \"@raycast/api\";\nimport { TrimmedString } from \"./trimmed.string\";\n\n/**\n * Abstraction around the raycast toast.\n * Show small notification at left bottom left corner.\n */\nexport class Toast {\n  private currentTitle = \"\";\n\n  constructor(private toast?: RaycastToast) {}\n\n  /**\n   * Show new toast or modify existing one.\n   */\n  show = async (options: RaycastToast.Options): Promise<void> => {\n    this.currentTitle = options.title;\n\n    if (this.toast != null) {\n      if (options.title != null) {\n        this.toast.title = options.title;\n      }\n\n      if (options.style != null) {\n        this.toast.style = options.style;\n      }\n\n      if (options.primaryAction != null) {\n        this.toast.primaryAction = options.primaryAction;\n      }\n\n      if (options.secondaryAction != null) {\n        this.toast.secondaryAction = options.secondaryAction;\n      }\n\n      return;\n    }\n\n    this.toast = await showToast(options);\n  };\n\n  /**\n   * Updating progress with current title modification.\n   * @example `Encoding Some Path To File` -> `Encoding Some Path To F... 30%`\n   */\n  updateProgress = async (progress: number): Promise<void> => {\n    const trimmedString = new TrimmedString(this.currentTitle, 40);\n\n    if (this.toast == null) {\n      throw new Error(\"Toast is not visible. Use `toast.show(...)` before\");\n    }\n\n    this.toast.title = `${trimmedString} ${progress}%`;\n  };\n}\n", "/**\n * Allows to trim any string to fixed length.\n * @example `new TrimmedString('My String', 2) -> `My...`\n */\nexport class TrimmedString {\n  constructor(\n    private readonly origin: string,\n    private readonly length: number,\n  ) {}\n\n  toString() {\n    if (this.origin.length < this.length) {\n      return this.origin;\n    }\n\n    return this.origin.substring(0, this.length) + \"...\";\n  }\n}\n"],
  "mappings": "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",
  "names": ["stabilize_exports", "__export", "Command", "__toCommonJS", "import_api", "import_api", "NoFilesProvidedException", "EncodeOperation", "files", "operation", "import_child_process", "import_path", "import_api", "VIDEO_FORMATS", "PATH", "FFMPEG_BINARY_CUSTOM_PATH", "import_api", "sanitizeFileName", "file", "isFileFormatSupported", "_filename", "filename", "VIDEO_FORMATS", "format", "import_child_process", "FsBinary", "foldersPath", "fileName", "args", "FfmpegBinaryNotFoundException", "Ffmpeg", "ffprobe", "callbacks", "ffmpegBinary", "FsBinary", "PATH", "path", "FFMPEG_BINARY_CUSTOM_PATH", "p", "payload", "input", "params", "output", "durationInSeconds", "resolve", "reject", "durationInMilliseconds", "command", "sanitizeFileName", "param", "ffmpegProcess", "data", "parts", "outTimeMs", "part", "parsed", "error", "code", "signal", "import_path", "import_fs", "import_promises", "import_path", "FsFile", "_path", "path", "options", "extension", "counter", "dirPath", "currentExtension", "baseName", "splitted", "lastPart", "digitsInName", "isLastPartDigits", "baseNameWithoutDigits", "nextName", "nextPath", "fs", "afs", "FfmpegVideo", "ffmpeg", "file", "options", "preset", "width", "height", "format", "videoPath", "sourceDirPath", "path", "extension", "targetVideoPath", "codec", "bitrate", "transforms", "FsFile", "import_child_process", "import_path", "FfprobeBinaryNotFoundException", "Ffprobe", "ffprobeBinary", "FsBinary", "PATH", "path", "FFMPEG_BINARY_CUSTOM_PATH", "p", "payload", "input", "params", "command", "sanitizeFileName", "param", "import_api", "import_api", "FinderIsNotFrontmostAppException", "SelectedFinderFiles", "filePath", "isFileFormatSupported", "FsFile", "SafeOperation", "origin", "toast", "err", "FfmpegBinaryNotFoundException", "FfprobeBinaryNotFoundException", "RaycastToast", "FinderIsNotFrontmostAppException", "NoFilesProvidedException", "import_api", "TrimmedString", "origin", "length", "Toast", "toast", "options", "progress", "trimmedString", "TrimmedString", "Command", "files", "SelectedFinderFiles", "toast", "Toast", "ffmpeg", "Ffmpeg", "Ffprobe", "progress", "SafeOperation", "EncodeOperation", "selectedFiles", "file", "RaycastToast", "FfmpegVideo"]
}
